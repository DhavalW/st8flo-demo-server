angular.module('StateFlow',[])


.constant('SF_FLOWTYPES',{
	entrypoint:1,
	condition:2,
	flow:3,
	terminal:4,
	error:5,
	external:6,
	callbackInt:7,
	callbackExt:99,		// Setting to extreme to make it un-addable. this is mainly used internally to represent a ref to callback flowtype in another module
	app:100
})



.service('stateFlowService',['$q','SF_FLOWTYPES', stateFlowService]);



function stateFlowService($q,SF_FLOWTYPES){

	/*==============================================================================================
		!!!!!!!!!!!!!!!~ StateFlow CLASS DEFINITION ~!!!!!!!!!!!!!!!!!!!!!!!!!
	/*============================================================================================== */

	/* StateFlow - Easy to read, Declarative State management and execution using DRY design principles

	How to use :

	Step 1 - 	Create a StateFlowObj... using StateFlowObj =  new StateFlow('name');
	Step 2 -  Define the conditions & their tests... using StateFlowObj.defineTest()
	Step 3 -	Define the flows & conditional branching ... using StateFlowObj.defineFlow()
	Step 4 - 	Define the various entry points into the flows... using StateFlowObj.defineEntryPoint(entrypointName)
	Step 5 -	Call StateFlowObj.execute('entrypointName') on that entrypoint as required.

	*/

	//Ensure StateFlow Global Object.
	if(!window.StateFlow)
		window.StateFlow = {};


	var StateFlow = function($q,SFService,httpService, aParams){
		//this._state={};
		this._name = aParams ? aParams._name ? aParams._name :''  : '';
		this._clientId = aParams ? aParams._clientId ? aParams._clientId :'' : '';
		this._execScript = aParams ? aParams._execScript ? aParams._execScript : true : true;	// Execute init scripts by default, unless spec as false (eg when in debugger.)
		this._SFService = SFService;
		this._$http = httpService;
		this._cbLinks = [];
		this._librariesFolder = aParams ? aParams._librariesFolder ? aParams._librariesFolder:'':'';
		this._initScript = "/* Init Script for SF: "+this._name+" for App: "+this._appName+" */";
		this.debugCallback = aParams ? aParams.debugCallback || null : null;

		// Take care to create objects with _<key> format. A mismatch could cause an endless loop
			// this._requires = [{_name:'sf_calculator',_fileName:'sf_calculator.sfmodule'}];

		this._requires = [];		// Holds multple objects, which indicate sub-SF modules required by this SF. This is checked against the passed modules array to verify if all dependencies are met. Imported & added to modules, if not.

		this._dependencies = function(p,sf){		// Holds sub SF objects which are dependencies. Passed verbatim to new SF objects as they're created.
			if(p && p._dependencies){				//- is a single collection passed on & shared across all possible dependencies & sub-dependecies (dependencies of dependencies)

				if(sf._dependencies)
					return sf._dependencies.push.apply(sf._dependencies, p._dependencies);
				else {
					return p._dependencies || [];
				}
			}
			else {
				return [];
			}
		}(aParams,this);

		this._appName = function(p,sf){
			if(p){
	 			if(p._appName)
					 return p._appName
				else {
					return sf._name;
				}
			}
		}(aParams,this);



		this._conditions= aParams ? aParams._conditions || {} : {};
		this._flows= aParams ?  aParams._flows || {} : {};
		this._entryPoints = aParams ? aParams._entryPoints || {} : {};

		this.SFCONTEXT = aParams ? aParams.SFCONTEXT || {} : {};
		this._idCounter = aParams ? aParams._idCounter || 0 : {};

		this.logState = function(){
			return angular.toJson(this._conditions,true);
		};

	//==============================================================================================
	/* Exports a stateflow object data, that is importable into another stateflow instance
	*/

		this.exportConfig = function(asModule){
			var exp = {
				_name:this._name,
				_appName:this._appName,
				_clientId:this._clientId,
				_requires:this._requires,
				_conditions:this._conditions,
				_flows:this._flows,
				_entryPoints:this._entryPoints,
				_idCounter:this._idCounter,
				_initScript:this._initScript,
				_fileName:this._fileName,
				_cbLinks:this._cbLinks
			};

			if(!asModule)
				exp._dependenciesPacked = this.packDependencies(this);

			return exp;
		};

		this.packDependencies = function(sf){
			if(sf._dependencies){
				var 	resultArr = [],
				 	_self = this;

				sf._dependencies.forEach(function(item){
					if(item._name != _self._name){
						resultArr.push({
							_name:item._name,
							_appName:item._appName,
							_clientId:item._clientId,
							_requires:item._requires,
							_conditions:item._conditions,
							_flows:item._flows,
							_entryPoints:item._entryPoints,
							_idCounter:item._idCounter,
							_initScript:item._initScript,
							_fileName:item._fileName,
							_cbLinks:item._cbLinks
						});
					}
				});
				return resultArr;
			}
		};


		this.setContext = function(paramObj){
			var _self = this;
			if(paramObj){
				for (pKey in paramObj){
					_self.SFCONTEXT[pKey] = paramObj[pKey];
				}
			}
		};


		/*	importConfig()
						- Imports a stateflow config & replaces it into "this" stateflow object, wiping out any previous config data
						WARNING !! - eval is used to execute "pInitScript". make sure code is correct & not malicious.

				pConfig - SF config json object

				pInitScript - SF Init script that needs to run after any config update, to add tests & actions(etc) to flows.
						Init script is also stored internally, in case a future refresh is required (eg after modifications to config)

				initParams [optional] - if a non-null object, sets the internal SF-wide context. any variable/object passed through this, becomes available across the init script declarations.
						stored internally as "this.SFCONTEXT" & available as stateFlowObj.SFCONTEXT.<param>

						( for eg :- initParams = {$scope:$scope}, will make available the angular-scope at importConfig function call,
						to tests & action declarations across initScript, as "stateFlowObj.SFCONTEXT.$scope" )

				bLoadScript [optional]- If false, it will preserve the internally stored initScript (only), else it'll load a fresh one from the module file, even if null.
						Config data must mandatorily be overwritten by passing a fresh one as a param.

				bDependency [optional] - if true, module is loaded as a dependency & will not overwrite _appName & _clientId.
						assumes that _appName & _clientId have already been assigned currently during creation.

		*/


		this.importConfig = function(pConfig, pInitScript,bLoadScript,bDependency){
			var 	_self = this,
				StateFlow = this;	// Used to provide a back reference to "this" stateflow obj in init scripts.

			_self._idCounter = 0;
			_self._requires = pConfig._requires || _self._requires;
			_self._fileName = pConfig._fileName || _self._fileName;
			_self._cbLinks = pConfig._cbLinks || _self._cbLinks;

			// _self._initParams = _self._initParams || initParams || {};	// Store so that it can be passed to dependencies

			_self._name=pConfig._name;
			if(!_self._dependencies || pConfig._dependenciesPacked)
				_self._dependencies = pConfig._dependencies || [];

			if(!bDependency){ // Prevent resetting appName & clientId, in case this SF is an already init dependency module.
				_self._clientId = pConfig._clientId;
				_self._appName = pConfig._appName;
			}


			_self._conditions={};
			_self._flows={};
			_self._entryPoints={};

			for(var key in pConfig._conditions){
				_self.defineTest(pConfig._conditions[key]);
			}
			for(var key in pConfig._flows){
				switch(pConfig._flows[key].flowType){
					case SF_FLOWTYPES.flow:
						_self.defineFlow(pConfig._flows[key]);
						break;

					case SF_FLOWTYPES.error:
						_self.defineError(pConfig._flows[key]);
						break;

					case SF_FLOWTYPES.terminal:
						_self.defineTerminal(pConfig._flows[key]);
						break;

					case SF_FLOWTYPES.external:
						_self.defineExternal(pConfig._flows[key]);
						break;

					case SF_FLOWTYPES.callbackInt:
						_self.defineCallback(pConfig._flows[key]);
						break;
				}

			}
			for(var key in pConfig._entryPoints){
				_self.defineEntryPoint(pConfig._entryPoints[key]);
			}



			if(bLoadScript && typeof pInitScript =="string" && pInitScript != ""){
				_self._initScript = pInitScript;
				if(_self._execScript){
					// console.log('DEBUG - INIT SCRIPT @ %s - Import Config() - executing EXTERNAL script = ',_self._name,pInitScript);
					eval(pInitScript);
				}
			}
			else if(_self._initScript && _self._execScript){
				// console.log('DEBUG - INIT SCRIPT @ %s - Import Config() - executing INTERNAL script = ',_self._name, _self._initScript);
				eval(_self._initScript);
			}


			_self.unpackDependencies(pConfig,bLoadScript,bDependency);

			_self.setupCallbacks();


			console.log('SF - Config Imported successfully as ',pConfig);
			console.log('SF - SF %s is now :',_self._name,_self);
			console.log('\n************************** SF LOADED *********************\n\n');

		};



		this.unpackDependencies = function(pConfig, bLoadScript,bDependency){
			if (pConfig._dependenciesPacked){
				var 	depArray = []
					_self = this;

				// If this is not a dependent module, push _self (core sf) in first
				if (!bDependency)
					depArray.push(_self);

				pConfig._dependenciesPacked.forEach(function(item){
					var s = new _self._SFService.StateFlow( $q, _self._SFService, _self._$http, {
						_appName:_self._appName,
						_clientId:_self._clientId,
						_execScript:_self._execScript,
						debugCallback:_self.debugCallback
					});
					s.setContext(_self.SFCONTEXT);
					s.importConfig(item ,item._initScript,bLoadScript,true);
					depArray.push(s);
				});

				depArray.forEach(function(item){
					item._dependencies = depArray;
				});

				_self._dependencies = depArray;

				return depArray;
			}
		};

		this.setupCallbacks = function(){
			var 	_self = this,
				cbArray = _self._cbLinks;

			if(_self && cbArray && cbArray.length > 0){

				cbArray.forEach(function(cbItem){
					var dep = getDepByName(_self,cbItem.cb.dep);
					if(dep){
						var cbFlow = dep._flows[cbItem.cb.name];
						if (cbFlow && cbFlow.flowType == SF_FLOWTYPES.callbackInt){
							if(cbItem.cb.branch)
								var branch = cbFlow.onTrue;
							else
								var branch = cbFlow.onFalse;

							if(branch.externals.length <= 0 || branch.externals.findIndex(function(item){
								return item.name == cbItem.name && item.dep == _self._name;
							}) < 0 ){
								branch.externals.push({
									dep: _self._name,
									name: cbItem.name
								});
							}

						}
					}
				});
			}
		};

		this.unlinkCallback = function(cbObj){
			var _self = this;
			if(cbObj && cbObj.name && cbObj.cb && cbObj.cb.dep && cbObj.cb.name && typeof cbObj.cb.branch !="undefined"){
				var dep = getDepByName(_self, cbObj.cb.dep);
				if(dep){
					var cbFlow = dep._flows[cbObj.cb.name];
					if(cbFlow && cbFlow.flowType == SF_FLOWTYPES.callbackInt){

						if(cbObj.cb.branch)
							cbFlow.onTrue.externals.splice(cbFlow.onTrue.externals.findIndex(function(item){
								return (item.name == cbObj.name) && (item.dep == _self._name);
							}),1);
						else
							cbFlow.onFalse.externals.splice(cbFlow.onFalse.externals.findIndex(function(item){
								return (item.name == cbObj.name) && (item.dep == _self._name);
							}),1);
					}
				}
			}
		};

		// Returns the SF dependency obj if found, undefined if not found.
		var getDepByName = function(sfObj, depKey){
			return sfObj._dependencies.find(function(item){
				return (item._name == depKey);
			});
		};

		// Wrapper function for above, to load a unified module file, instead of multiple seperate ones.
		this.importModule = function(moduleData,bLoadScript,bDependency,fileName){
			var 	pConfig = moduleData.sfConfig || {},
				pInitScript = moduleData.initScript || '';

			pConfig._fileName = fileName || pConfig._fileName;
			this.importConfig(pConfig,pInitScript,bLoadScript,bDependency);
			// this._fileName = fileName;

		};




		/*==============================================================================================
		/* DELETION HELPER Functions - removes any & all references of a given key from the entire SF configuration as applicable
			@accepts -pKey as string, name of a flow,ep or condition
		*/


		this.replaceAllFlowReferences = function(stateFlowObj,pKey,rKey){
			purgeFlowRefFrom(stateFlowObj._entryPoints,pKey,rKey);
			purgeFlowRefFrom(stateFlowObj._flows,pKey,rKey);
		};

		this.purgeAllFlowReferences = function(stateFlowObj,pKey){
			purgeFlowRefFrom(stateFlowObj._entryPoints,pKey,null);
			purgeFlowRefFrom(stateFlowObj._flows,pKey,null);
		};

		var purgeFlowRefFrom = function(objCol,pKey,rKey){
			var 	objKey,objItem,idx;
			for (objKey in objCol){
				objItem = objCol[objKey];
				switch(objItem.flowType){
					case SF_FLOWTYPES.entrypoint:
						if (objItem.children){
							idx = objItem.children.indexOf(pKey);
							if (idx > -1){
								if(rKey)
									objItem.children[idx] = rKey;	// Replace directly, with new value
								else
									objItem.children.splice (idx,1);	// Or splice & remove the existing
							}
						}
						break;
					case SF_FLOWTYPES.condition:
						break;
					case SF_FLOWTYPES.flow:
					case SF_FLOWTYPES.terminal:
					case SF_FLOWTYPES.error:
					case SF_FLOWTYPES.external:
					case SF_FLOWTYPES.callbackInt:

						if (objItem.onTrue && objItem.onTrue.nextFlow){
							idx = objItem.onTrue.nextFlow.indexOf(pKey);
							if(idx > -1){
								if(rKey)
								 	objItem.onTrue.nextFlow[idx] = rKey;
								else
								 	objItem.onTrue.nextFlow.splice (idx,1);
							}
						}

						if (objItem.onFalse && objItem.onFalse.nextFlow){
							idx = objItem.onFalse.nextFlow.indexOf(pKey);
							if(idx > -1){
								if(rKey)
								 	objItem.onFalse.nextFlow[idx] = rKey;
								else
								 	objItem.onFalse.nextFlow.splice(idx,1);
							}
						}
				}
			}
		};


		this.purgeAllConditionReferences = function(stateFlowObj,pKey){
			purgeCondRefFrom(stateFlowObj._entryPoints,pKey);
			purgeCondRefFrom(stateFlowObj._flows,pKey);
		};

		var purgeCondRefFrom = function(objCol,pKey){
			var 	objKey,objItem;
			for (objKey in objCol){
				objItem = objCol[objKey];
				switch(objItem.flowType){
					case SF_FLOWTYPES.entrypoint:
						if (objItem.initialConditionsArray && objItem.initialConditionsArray.indexOf(pKey) > -1)
							objItem.initialConditionsArray.splice (objItem.initialConditionsArray.indexOf(pKey),1);

						if (objItem.mustEvaluateArray && objItem.mustEvaluateArray.indexOf(pKey) > -1)
							objItem.mustEvaluateArray.splice (objItem.mustEvaluateArray.indexOf(pKey),1);

						break;
					case SF_FLOWTYPES.condition:
						break;
					case SF_FLOWTYPES.flow:
					case SF_FLOWTYPES.terminal:
					case SF_FLOWTYPES.error:
					case SF_FLOWTYPES.external:
					case SF_FLOWTYPES.callbackInt:
					if (objItem.when && objItem.when.state_is && objItem.when.state_is.indexOf(pKey) > -1)
						objItem.when.state_is.splice (objItem.when.state_is.indexOf(pKey),1);

					if (objItem.when && objItem.when.butNot && objItem.when.butNot.indexOf(pKey) > -1)
						objItem.when.butNot.splice (objItem.when.butNot.indexOf(pKey),1);

					if (objItem.mustEvaluateArray && objItem.mustEvaluateArray.indexOf(pKey) > -1)
						objItem.mustEvaluateArray.splice (objItem.mustEvaluateArray.indexOf(pKey),1);
				}
			}
		};


	//==============================================================================================

		// defines a condition & its associdated testing function
		// name : string
		// Fn MUST return a promise that resolves to true / false, based on which future actions are taken, OR rejects with error to disrupt the flow
		this.defineTest = function(options){

			console.log('SF - setting up Condition definition for %s',name);
			if(typeof options.name != 'undefined'){
				this._conditions[options.name] = {
					flowType:SF_FLOWTYPES.condition,
					value:false,
					evaluated:false,
					name:options.name,
					description:options.description,
					Fn:options.Fn,
					params:options.params,
					testFn:function(originFlow,stateFlowObj,ctx,prevOp){
						var _self = this;
						if(_self.Fn){
							console.log('inside Condition [%s] : Fn found. calling with ctx & self as : ',_self.name, ctx, _self);
							return $q(function(resolve,reject){
									try{
										resolve(_self.Fn (originFlow,stateFlowObj,ctx,prevOp));
									}catch(e){
										reject(e);
									}
								})
								.then(function s(val){
									_self.evaluated = true;
									_self.value = val;
									console.log('inside Condition [%s] : Fn executed. result is : ',_self.name, val);

									return $q.resolve(val);
								}, function f(err){
									console.log('inside Condition [%s] : Fn executed with ERROR. err is : ',_self.name, err);

									return $q.reject(err);
								})
								.catch(function(err){
									return $q.reject(err);
								});
						}
						else{
							console.log('inside Condition [%s] : Fn NOT found. resolving directly as ',_self.name, _self.value);

							_self.evaluated = true;
							return $q.resolve(_self.value);
						}

					}
				};
			}

		};

		this.updateTest = function(options){
			console.log('SF - updating Condition definition for %s',options.name);
			if(typeof options.name != 'undefined'){
				this._conditions[options.name].flowType = options.flowType ? options.flowType : this._conditions[options.name].flowType;
				this._conditions[options.name].value = options.value ? options.value : this._conditions[options.name].value;
				this._conditions[options.name].evaluated = options.evaluated ? options.evaluated : this._conditions[options.name].evaluated;
				this._conditions[options.name].description = options.description ? options.description : this._conditions[options.name].description;
				this._conditions[options.name].Fn = options.Fn ? options.Fn : this._conditions[options.name].Fn;
				this._conditions[options.name].params = options.params ? options.params : this._conditions[options.name].params;
			}
		};

		this.deleteTest = function(name) {
			delete this._conditions[name];
			this.purgeAllConditionReferences(this,name);
		};


		/* ==============================================================================================
			A state is similar in operation to a condition, except it doesn't have any test function to be evaluated.
			Instead, a corresponding terminal updates the value of this state, depending on it own execution.
			The state can then be inserted into other flows like a condition & will affect that flows execution depending
			on what was set by the corresponding terminal
		*/

		this.defineState = function(options){

			console.log('SF - setting up State definition for %s',options.name);
			if(typeof options.name != 'undefined'){
				var _name = 'S_'+options.name;
				this._conditions[_name] = {
					flowType:SF_FLOWTYPES.condition,
					value:false,
					evaluated:false,
					name:_name,
					description:options.description,
					testFn:function(){
						return $q.resolve(this.value);
					}
				};
			}

		};

		this.deleteState = function(terminalName) {
			delete this._conditions['S_'+terminalName];
			this.purgeAllConditionReferences(this,'S_'+ terminalName);
		};

	//==============================================================================================

		/*
		 defineFlow - defines a flow invoked using flowName.execute() OR stateFlowObj.executeFlow(flowName)
		 & contains an atomic set of actions that must be executed based on the supplied condition set evaluation.

		 Accepts -
			 name : string
			 options : object = {
				mustEvaluateArray : array of conditions that must be re-evaluated before execution. This is applied first
				when : Obj of conditions {state_is:[],butNot:[]} (at least one condition required), which is evaluated to decide which fn from below is pushed to execution stack
				fnFlowOnTrue : function
				paramsOnTrue : param object for true fn
				fnFlowOnFalse: function
				paramsOnFalse : param object for false fn
			}

		Returns -
			a traversible result object = {
				name : name of the flow,
				value : which branch exectued (true or false)
				children : an object of subtrees that have executed
			}

		NOTE : - options.flowOnTrue/False are custom functions that
			should accept :
			 	_params		- params set at the time of declaration
				originFlow	- ref to the parent flow object of the function
				stateFlowObj	- ref to main controlling stateflow

			& MUST RETURN A PROMISE that resolves to true if succesfully executed / false if not, OR rejects if error
		*/

		this.defineFlow = function(options ){
			var _self = this;

			if(typeof options.name != 'undefined'){
				console.log('SF - setting up Flow definition for %s, id = %s',options.name,_self._idCounter);
				_self._flows[options.name] = {
					name :options.name,
					description:options.description,
					flowId:Number(_self._idCounter),
					flowType:options.flowType || SF_FLOWTYPES.flow,
					//stateFlowObj:_self,
					when:{
						state_is: (options.when && options.when.state_is)? options.when.state_is : [],
						butNot: (options.when && options.when.butNot)? options.when.butNot : []
					},
					mustEvaluateArray:options.mustEvaluateArray || [],
					terminalResponse : options.terminalResponse || null,
					onTrue:{
						action: (options.onTrue && options.onTrue.action) ? options.onTrue.action : null,
						nextFlow: (options.onTrue && options.onTrue.nextFlow) ? options.onTrue.nextFlow : []
					},
					onFalse:{
						action: (options.onFalse && options.onFalse.action) ? options.onFalse.action : null,
						nextFlow: (options.onFalse && options.onFalse.nextFlow) ? options.onFalse.nextFlow : []
					},

					fnHandler: function(Fn, originFlow, stateFlowObj,ctx,prevOp,flowState){
						if (Fn){
							if(originFlow.flowType != SF_FLOWTYPES.external && originFlow.flowType != SF_FLOWTYPES.callbackInt ){
								try{
									return $q.resolve({
										output:Fn(originFlow,stateFlowObj,ctx,prevOp),
										state:flowState
									});

								}catch(e){
									return $q.reject(e);
								}
							}else{
								try{
									var retVal = Fn(originFlow,stateFlowObj,ctx,prevOp);
									retVal.state = flowState;
									return retVal;
								}catch(e){
									return $q.reject(e);
								}
							}
						}
						else
							return $q.resolve({
								output:null,
								state:flowState
							});

					}
				};

				_self._idCounter++;

				return _self._flows[options.name];

			}else {
				console.log('SF - invalid flow name supplied for %s. cannot define', options.name);
			}
		};




		this.updateFlow = function(options){
			if(typeof options.name != 'undefined'){

				this._flows[options.name].flowType = options.flowType ? options.flowType : this._flows[options.name].flowType;
				this._flows[options.name].description = options.description ? options.description : this._flows[options.name].description;
				this._flows[options.name].flowId = options.flowId ? options.flowId : this._flows[options.name].flowId;
				this._flows[options.name].mustEvaluateArray = options.mustEvaluateArray ? options.mustEvaluateArray : this._flows[options.name].mustEvaluateArray;
				this._flows[options.name].terminalResponse = options.terminalResponse ? options.terminalResponse : this._flows[options.name].terminalResponse;

				if(options.when){
					if(!this._flows[options.name].when)
						this._flows[options.name].when = {state_is:[],butNot:[]};
					this._flows[options.name].when.state_is = options.when.state_is ? options.when.state_is : this._flows[options.name].when.state_is;
					this._flows[options.name].when.butNot = options.when.butNot ? options.when.butNot : this._flows[options.name].when.butNot;
				}

				if(options.onTrue){
					if(!this._flows[options.name].onTrue)
						this._flows[options.name].onTrue = {params:[],action:null,nextFlow:[]};
					this._flows[options.name].onTrue.action = options.onTrue.action ? options.onTrue.action : this._flows[options.name].onTrue.action;
					this._flows[options.name].onTrue.nextFlow = options.onTrue.nextFlow ? options.onTrue.nextFlow : this._flows[options.name].onTrue.nextFlow;
					this._flows[options.name].onTrue.externals = options.onTrue.externals ? options.onTrue.externals : this._flows[options.name].onTrue.externals;
				}

				if(options.onFalse){
					if(!this._flows[options.name].onFalse)
						this._flows[options.name].onFalse = {params:[],action:null,nextFlow:[]};
					this._flows[options.name].onFalse.action = options.onFalse.action ? options.onFalse.action : this._flows[options.name].onFalse.action;
					this._flows[options.name].onFalse.nextFlow = options.onFalse.nextFlow ? options.onFalse.nextFlow : this._flows[options.name].onFalse.nextFlow;
					this._flows[options.name].onFalse.externals = options.onFalse.externals ? options.onFalse.externals : this._flows[options.name].onFalse.externals;
				}

			}

		};

		this.deleteFlow = function(name) {
			console.log('SFObj - deleting flow named ',name);

			var 	_self = this,
				flowType = _self._flows[name].flowType;

			delete _self._flows[name];

			if(flowType == SF_FLOWTYPES.terminal || flowType == SF_FLOWTYPES.error)
				_self.deleteState(name);

			_self.purgeAllFlowReferences(_self,name);

		};


		/* Externals must be an array of objects as follows
			Externals = [{
				key:'<name-of-entryPoint>',
				dependency:'_name of dependency in which Ep exists'
			}]
		*/
		this.defineExternal = function(options){
			options.flowType = SF_FLOWTYPES.external;
			var flow = this.defineFlow(options);
			if (flow){
				flow.external = true;


				if(!flow.onTrue){
					flow.onTrue = {
						externals:[],
						action:null,
						nextFlow:[]
					};
				}


				flow.onTrue.externals =options.onTrue && options.onTrue.externals ? options.onTrue.externals : [];
				flow.onTrue.action = function(originFlow,stateFlowObj,ctx,prevOp){
					var 	promiseArray = [],
					 	actionOp = {};

					originFlow.onTrue.externals.forEach(function(ext){
						var dep = stateFlowObj._dependencies.find(function(item){
							return item._name == ext.dep;
						});
						if(dep){

							actionOp[ext.name] = {
								ctx:sf_clone(ctx),
								output:null,
								moduleName:ext.dep
							}
							promiseArray.push(dep.execute(ext.name,actionOp[ext.name].ctx,prevOp));
						}
						else {
							return $q.reject('Could not find dependency %s in onTrue Externals of Flow %s',ext.dep,originFlow.name);
						}

					});
					return $q.all(promiseArray)
						.then(function s(results){
							var aItem = {};
							for(var i=0; i<results.length; i++){

								aItem = actionOp[results[i].entryPointName];
								aItem.output = results[i].output;

								// Merge the same actionOp item into ctx, but under <moduleName>
								// This will make it available across core SF as ctx.<moduleName>.<epName>.<ctx / output>
								if(!ctx[aItem.moduleName])
								 	ctx[aItem.moduleName]= {};

								ctx[aItem.moduleName][results[i].entryPointName] = aItem;


							}
							return actionOp;
						},function f(err){
							return $q.reject(err);
						});
				};


				if(!flow.onFalse){
					flow.onFalse = {
						externals:[],
						action:null,
						nextFlow:[]
					};
				}



				flow.onFalse.externals = options.onFalse && options.onFalse.externals ? options.onFalse.externals : [];
				flow.onFalse.action = function(originFlow,stateFlowObj,ctx,prevOp){
					var 	promiseArray = [],
					 	actionOp = {};

					originFlow.onFalse.externals.forEach(function(ext){
						var dep = stateFlowObj._dependencies.find(function(item){
							return item._name == ext.dep;
						});
						if(dep){
							actionOp[ext.name] = {
								ctx:sf_clone(ctx),
								output:null
							}
							promiseArray.push(dep.execute(ext.name,actionOp[ext.name].ctx,prevOp));
						}
						else {
							return $q.reject('Could not find dependency %s in onFalse Externals of Flow %s',ext.dep,originFlow.name);
						}
					});
					return $q.all(promiseArray)
						.then(function s(results){
							var aItem = {};
							for(var i=0; i<results.length; i++){

								aItem = actionOp[results[i].entryPointName];
								aItem.output = results[i].output;

								// Merge the same actionOp item into ctx, but under <moduleName>
								// This will make it available across core SF as ctx.<moduleName>.<epName>.<ctx / output>
								if(!ctx[aItem.moduleName])
								 	ctx[aItem.moduleName]= {};

								ctx[aItem.moduleName][results[i].entryPointName] = aItem;


							}
							return actionOp;
						},function f(err){
							return $q.reject(err);
						});
				};

				return flow;
			}
		};


		// Similar to an external in most respects, except flowType ID & that it does not reject if a dependency is not found.
		this.defineCallback = function(options){
			options.flowType = SF_FLOWTYPES.callbackInt;
			var flow = this.defineFlow(options);
			if (flow){
				flow.external = true;


				if(!flow.onTrue){
					flow.onTrue = {
						externals:[],
						action:null,
						nextFlow:[]
					};
				}


				flow.onTrue.externals =options.onTrue && options.onTrue.externals ? options.onTrue.externals : [];
				flow.onTrue.action = function(originFlow,stateFlowObj,ctx,prevOp){
					var 	promiseArray = [],
					 	actionOp = {};

					originFlow.onTrue.externals.forEach(function(ext){
						var dep = stateFlowObj._dependencies.find(function(item){
							return item._name == ext.dep;
						});
						if(dep){

							actionOp[ext.name] = {
								ctx:sf_clone(ctx),
								output:null,
								moduleName:ext.dep
							}
							promiseArray.push(dep.execute(ext.name,actionOp[ext.name].ctx,prevOp));
						}
						// else {
						// 	return $q.reject('Could not find dependency %s in onTrue Externals of Flow %s',ext.dep,originFlow.name);
						// }

					});
					return $q.all(promiseArray)
						.then(function s(results){
							var aItem = {};
							for(var i=0; i<results.length; i++){

								aItem = actionOp[results[i].entryPointName];
								aItem.output = results[i].output;

								// Merge the same actionOp item into ctx, but under <moduleName>
								// This will make it available across core SF as ctx.<moduleName>.<epName>.<ctx / output>
								if(!ctx[aItem.moduleName])
								 	ctx[aItem.moduleName]= {};

								ctx[aItem.moduleName][results[i].entryPointName] = aItem;


							}
							return actionOp;
						},function f(err){
							return $q.reject(err);
						});
				};


				if(!flow.onFalse){
					flow.onFalse = {
						externals:[],
						action:null,
						nextFlow:[]
					};
				}



				flow.onFalse.externals = options.onFalse && options.onFalse.externals ? options.onFalse.externals : [];
				flow.onFalse.action = function(originFlow,stateFlowObj,ctx,prevOp){
					var 	promiseArray = [],
					 	actionOp = {};

					originFlow.onFalse.externals.forEach(function(ext){
						var dep = stateFlowObj._dependencies.find(function(item){
							return item._name == ext.dep;
						});
						if(dep){
							actionOp[ext.name] = {
								ctx:sf_clone(ctx),
								output:null
							}
							promiseArray.push(dep.execute(ext.name,actionOp[ext.name].ctx,prevOp));
						}
						// else {
						// 	return $q.reject('Could not find dependency %s in onFalse Externals of Flow %s',ext.dep,originFlow.name);
						// }
					});
					return $q.all(promiseArray)
						.then(function s(results){
							var aItem = {};
							for(var i=0; i<results.length; i++){

								aItem = actionOp[results[i].entryPointName];
								aItem.output = results[i].output;

								// Merge the same actionOp item into ctx, but under <moduleName>
								// This will make it available across core SF as ctx.<moduleName>.<epName>.<ctx / output>
								if(!ctx[aItem.moduleName])
								 	ctx[aItem.moduleName]= {};

								ctx[aItem.moduleName][results[i].entryPointName] = aItem;


							}
							return actionOp;
						},function f(err){
							return $q.reject(err);
						});
				};

				return flow;
			}
		};


		this.findDependency = function(external,sfObj){
			return sfObj._dependencies.find(function(item){
				return item.name == external.key;
			});
		};

	//==============================================================================================


		/* defineEntryPoint - Sets up an external entry point for the execution cycle
			options = {
				name : name of the entry point
				flowName : name of the flow that should be a starting point
				initialConditionsArray : array of {name: conditionName, value: conditionValue} objects which identify the conditions & the values they need to be set to, before execution of flow.
				mustEvaluateArray : conditions that must be re-evaluated at first check within the cycle defined by this entry point
			}
		*/
		this.defineEntryPoint= function(options){
			if(options.name){
				this._entryPoints[options.name] = {
					name:options.name,
					children: options.children || [],
					flowType:SF_FLOWTYPES.entrypoint,
					description : options.description || "",
					initialConditionsArray : options.initialConditionsArray || [],
					mustEvaluateArray:options.mustEvaluateArray || [],
					exported : (typeof options.exported !="undefined" && options.exported != null)? options.exported : true,
					action:options.action || null,
					actionHandler:function(entryPoint,sfObj,context,prevOp){
						var _self = this;
						if(_self.action)
							_self.action(entryPoint,sfObj,context,prevOp);
						return $q.resolve(context);
					}
				};
			}else
				console.log('SF - Entry point [%s] could not be defined. bad minimum config options',options.name);

		};


		this.updateEntryPoint = function (options){
			if(options.name){
				this._entryPoints[options.name].flowType = options.flowType ? options.flowType : this._entryPoints[options.name].flowType;
				this._entryPoints[options.name].children = options.children ? options.children : this._entryPoints[options.name].children;
				this._entryPoints[options.name].initialConditionsArray = options.initialConditionsArray ? options.initialConditionsArray : this._entryPoints[options.name].initialConditionsArray;
				this._entryPoints[options.name].mustEvaluateArray = options.mustEvaluateArray ? options.mustEvaluateArray : this._entryPoints[options.name].mustEvaluateArray;
				this._entryPoints[options.name].description = options.description ? options.description : this._entryPoints[options.name].description;
				this._entryPoints[options.name].exported = (typeof options.exported !="undefined" && options.exported != null)? options.exported : this._entryPoints[options.name].exported;
				this._entryPoints[options.name].action = options.action ? options.action : this._entryPoints[options.name].action;
			}
		};

		this.deleteEntryPoint = function(name) {
			delete this._entryPoints[name];
			this.purgeAllFlowReferences(this,name);
		};


		//==============================================================================================


			/* defineTerminal - Sets up an exit point for the execution cycle
				Can have an optional set of conditions that (if valid) will activate this flow's action.
				options = {
					name : name of the entry point
					when : {state_is:['cond1','cond2']}
					action : function that must be executed on hitting this termination point
					params : params to be passed to the function
				}
			*/
			this.defineTerminal= function(options){

				if(options.name){
					var _options = {
						name : options.name,
						flowType:SF_FLOWTYPES.terminal,
						terminalResponse: options.terminalResponse || options.name,
						mustEvaluateArray:options.mustEvaluateArray || [],
						when:options.when,
						onTrue:options.onTrue,
						onFalse:options.onFalse
					};

					console.log('SF - defining terminal & state : %s as', options.name,_options);
					this.defineFlow(_options);
					this.defineState(_options);


				}else
					console.log('SF - terminal/state [%s] could not be defined. bad minimum config options',options.name);

			};
		//==============================================================================================


			/* defineError - Sets up an error exit point for the execution cycle
				Can have an optional set of conditions that (if valid) will activate this flow's action.
				options = {
					name : name of the entry point
					when : {state_is:['cond1','cond2']}
					action : function that must be executed on hitting this termination point
					params : params to be passed to the function
				}
			*/
			this.defineError= function(options){

				if(options.name){
					var _options = {
						name : options.name,
						flowType:SF_FLOWTYPES.error,
						terminalResponse: options.terminalResponse || '[ERROR] - '+options.name,
						mustEvaluateArray:options.mustEvaluateArray || [],
						when:options.when,
						onTrue:options.onTrue,
						onFalse:options.onFalse
					};

					console.log('SF - defining error terminal : %s as', options.name,_options);
					this.defineFlow(_options);
					this.defineState(_options);


				}else
					console.log('SF - error terminal point [%s] could not be defined. bad minimum config options',options.name);

			};



	//==============================================================================================

		// Helper function to execute any given flow by name.
		this.executeFlow = function(flowName,seqID,ctx,prevOp){
			var 	_stateFlowObj = this,
				_originFlow = _stateFlowObj._flows[flowName],
				strContext ='';

			if (_originFlow){
				var 	_onTrue = _originFlow.onTrue,
					_onFalse = _originFlow.onFalse;

				if (seqID == null){
					seqID = _originFlow.flowId.toString()+'.'+ _originFlow.flowType.toString();
				}else {
					seqID += '-'+ _originFlow.flowId.toString()+'.'+ _originFlow.flowType.toString();
				}

				// first set all conditions that must be evaluated
				_stateFlowObj.mustEvaluate(_originFlow.mustEvaluateArray);

				// set the flow context for conditions
				ctx.flow = _originFlow.name;

				// Now check for condition validity & schedule appropriate fn
				console.log('\n\n***************************** SF - executing FLOW : %s, *******************************\n\tseqID is now ', _originFlow.name,seqID);
				return _stateFlowObj.checkIf(_originFlow,ctx,prevOp)
					.then (function s(validity){
						// if conditions are met, set execution to true related function & params
						console.log('\tconditions for %s evaluated as ',_originFlow.name,validity);
						if (validity == true){
							var _fn = _onTrue.action;
							var _nextFlow = _onTrue.nextFlow;
							seqID += '.T';
						}

						// if false, set to false related function & params
						else if (validity == false){
							var _fn = _onFalse.action;
							var _nextFlow = _onFalse.nextFlow;
							seqID += '.F';
						}

						// If validity is neither true nor false
						else {
							return $q.reject('Unexpected problem. got validity as '+ validity + ', instead of boolean'); 	// Some unexpected problem, so bubble it up by rejecting with its value
						}

						// if this flow is a terminal, find its corresponding state & set the value = validity (ie either true or false);
						if (_originFlow.flowType == SF_FLOWTYPES.terminal || _originFlow.flowType == SF_FLOWTYPES.error){
							_stateFlowObj._conditions['S_'+_originFlow.name].value = validity;
						}

						// If we've reached this far, stage is set... so execute
						return _originFlow.fnHandler(_fn, _originFlow, _stateFlowObj,ctx,prevOp,validity)

								.then (function (actionOp){	// FnHandler resolves with the return value of action
									console.log("\tStringifying context returned from %s flow's action as ",_originFlow.name,ctx);
									strContext = JSON.stringify({context:ctx,prevOp:prevOp, actionOp:actionOp});

									// if _nextFlow has any items in it, it means there's as sub-tree to execute.
									if(_nextFlow.length > 0){
										console.log("\tExecuting subflows",_nextFlow);

										return _stateFlowObj.executeFlows(_nextFlow,seqID,ctx,actionOp)
											.then (function s(resArray){

												var arrLength = resArray.length;
												var seqArray = [];
												var terminalResponses = [];

												for (var i=0; i<arrLength; i++){
													seqArray.push.apply(seqArray,resArray[i].sequence);
													if(resArray[i].terminalResponses)
														terminalResponses.push.apply(terminalResponses,resArray[i].terminalResponses);
													//console.log('SF - Debug - Flow %s (#%s) executed, sequence returned is ',_originFlow.name,_originFlow.flowID,resArray[i].sequence,resArray[i]);
												}

												if (_originFlow.flowType == SF_FLOWTYPES.terminal || _originFlow.flowType == SF_FLOWTYPES.error)
													terminalResponses.push(_originFlow.terminalResponse);


												// Return a tree of all sub flows that were executed, with their individual response values & sub trees.
												var result = {
													name:_originFlow.name,
													value:actionOp,
													branch:validity,
													context:strContext,
													terminalResponses:terminalResponses,
													sequence:seqArray,
													children:resArray
												};

												console.log("\a\t*** All subflows executed for flow: %s",_originFlow.name);

												return $q.resolve(result);

											}, function f(err){

												// * Note - err will always be a SINGLE object returned from the rejecting promise. (source - docs for $q.all)

												var result = {
													name:_originFlow.name,
													value:err.value,
													branch:validity,
													context:strContext,
													terminalResponses: err.terminalResponses,
													sequence:err.sequence,
													children:err
												};
												return $q.reject(result);
											});
									}

									// Else, This must be a leaf node (no more sub trees)
									else{
										// return value & name of this flow as usual, but set next to null as there are no more sub-trees.
										var result = {
											name:_originFlow.name,
											value:actionOp,
											branch:validity,
											context:strContext,
											sequence:[seqID],
											children:null
										};

										if (_originFlow.flowType == SF_FLOWTYPES.terminal || _originFlow.flowType == SF_FLOWTYPES.error)
											result.terminalResponses = [_originFlow.terminalResponse];
										console.log('*** Flow %s is a leaf & finished exec.',_originFlow.name);
										return $q.resolve(result);
									}

								}, function f(err){
									var result = {
										name:_originFlow.name,
										value:' | Error in '+ _originFlow.name + ' flow action : ' + err,
										branch:validity,
										context:JSON.stringify(ctx),
										terminalResponses:['[ERROR] - error in '+ _originFlow.name + ' action : '+ err],
										sequence:[seqID],
										children:null
									};
									return $q.reject(result);
								})

								.catch(function(err){
									return $q.reject(err);
								});

					}, function f(err){
						var result = {
							name:_originFlow.name,
							value:' | Error in '+ _originFlow.name + ' flow condition eval : ' + err,
							context:JSON.stringify(ctx),
							terminalResponses:['[ERROR] - error in '+ _originFlow.name + ' condition : '+ err],
							sequence:[seqID],
							children:null
						};
						return $q.reject(result); // error occurred while checking condition, bubble up.
					})

					.catch(function(err){
						return $q.reject(err);
					});

			}

			else {
				return $q.reject('Flow : '+ flowName +' - Not found. Cannot execute');
			}
		};



		// Helper function to execute an array of function names.
		this.executeFlows = function(flowArray,seqID,ctx,actionOp){
			var _stateFlowObj = this;
			var arrLength = flowArray.length;
			var promiseArray = [];

			// if flowArray has any items in it, it means there's a sub-tree to execute.
			if(arrLength>0){

				for (var i=0; i< arrLength; i++){

					promiseArray.push(_stateFlowObj.executeFlow(flowArray[i],seqID,ctx,actionOp));

				}
			}

			return $q.all(promiseArray);
		};



	//==============================================================================================

		// Executes an entry point
		/*
			initialConditionsArray = [ {
				name : name of a defined condition
				value : value to set it to
			} ]
		*/
		this.execute = function(entryPointName,context,prevOp){
			var _stateFlowObj = this;
			var entryPoint = _stateFlowObj._entryPoints[entryPointName];
			var 	_context = context || {},
				strContext ='';

			if (entryPoint){
				var _initialConditionsArray = entryPoint.initialConditionsArray;

				// first set all conditions that must be evaluated
				_stateFlowObj.mustEvaluate(entryPoint.mustEvaluateArray);


				// next setup context
				_context.entryPoint = _context[entryPoint.name] = {};
				_context[entryPoint.name].output = null;
				if (!prevOp)
					prevOp = {
						output:{},
						state:true		// By default the true side executes, so to maintain consistency.
					};

				// next, Set initial conditions as defined in the entry point
				var arrLength = _initialConditionsArray.length;
				for (var i=0; i< arrLength; i++){
					_stateFlowObj._conditions[_initialConditionsArray[i].name].value = _initialConditionsArray[i].value;
				}


				console.log('\n\n****************** ENTRY POINT EXECUTED : %s **************************',entryPointName);
				console.log('Context is ',context);
				console.log('***************************************\n\n');

				// execute the associated flow.
				return entryPoint.actionHandler(entryPoint,_stateFlowObj,_context,prevOp)
					.then(function s(ctx){
						strContext = JSON.stringify(ctx);
						return _stateFlowObj.executeFlows(entryPoint.children,null,ctx,prevOp);
					})
					.then(function s(epoint_Res){

						var result = {
							name:_stateFlowObj._name,
							appName:_stateFlowObj._appName,
							clientId:_stateFlowObj._clientId,
							type:'Success',
							entryPointName:entryPointName,
							entryPointResponse : epoint_Res,
							context:strContext,
							conditionState:_stateFlowObj.getConditionState(),
							output:_context[entryPointName].output
						};

						if (_stateFlowObj.debugCallback){
							_stateFlowObj.debugCallback(null, result);	// setting err parameter to null to indicate success
						}

						return $q.resolve(result);

					}, function f(epoint_Res){

						var result = {
							name:_stateFlowObj._name,
							appName:_stateFlowObj._appName,
							clientId:_stateFlowObj._clientId,
							type:'Error',
							entryPointName:entryPointName,
							entryPointResponse : [epoint_Res],
							context:strContext,
							conditionState:_stateFlowObj.getConditionState(),
							output:_context[entryPointName].output
						};

						if (_stateFlowObj.debugCallback){
							_stateFlowObj.debugCallback(result.type, result);
						}

						return $q.reject(result);

					})
					.catch(function(err){
						return $q.reject(err);
					});
			}else {
				return $q.reject('Entry Point [ '+ entryPointName + ' ] was not found. Cannot execute');
			}

		};


		this.getConditionState = function(){
			var resultObj = {};

			for (var cKey in this._conditions){
				resultObj[cKey] = {
					name:cKey,
					evaluated:this._conditions[cKey].evaluated,
					value:this._conditions[cKey].value
				}
			}

			return resultObj;
		};

	//==============================================================================================

		// Evaulates a given set of conditions & returns a promise that resolves to true if all are true, or false otherwise. Rejects only on error
		// to re-evaluate a supplied condition, mark it's "evaluated" property  using below function before calling this.
		// expects param = { state_is : [<condition1>,<condition2>,...], butNot: [condition1, condition2, ...]}

		this.checkIf = function(originFlow,ctx,prevOp){
			var _stateFlowObj = this;
			var result = true;		// defaulted to true, so it will only remain true if all conditions are true, else it'll automatically become false as true && falsy = false
			var evalStack = [];
			var isCLabelArray = originFlow.when.state_is || [];
			var notCLabelArray = originFlow.when.butNot || [];

			// First do a run through to check if any conditions need evaluation & evaluate them
			var isArrLength = isCLabelArray.length;
			var notArrLength = notCLabelArray.length;

			console.log ("\t*** CheckIf ***\ncheckIf - Evaluating (%s) is-conditions & (%s) not-conditions as ",isArrLength,notArrLength,isCLabelArray,notCLabelArray);
			console.log ("\tContext is : ",ctx);
			console.log ("\tSFObj is : ",_stateFlowObj);
			evalStack.push( eval_IsCLabelArray(originFlow,_stateFlowObj,isCLabelArray,0,isArrLength,ctx,prevOp) );
			evalStack.push( eval_NotCLabelArray(originFlow,_stateFlowObj,notCLabelArray,0,notArrLength,ctx,prevOp) );


			// Once all conditions in the stack are evaluated for sure,
			return $q.all(evalStack)
				.then(function s(resArray){
					console.log ("\tcheckIf - condition stack evaluated as  ",resArray);

					result = resArray[0] && resArray[1];

					console.log("\tCheckIF - RESOLVED to value [ %s ]. returning.",result);
					console.log("\n----------------\n");
					return $q.resolve(result); // If all went well, we should have the final result.

				},function f(err){	// if any of the evaluations reject, then reject this whole operation
					return $q.reject(err);
				})
				.catch(function(err){
					return $q.reject(err);
				});



		};


	//==============================================================================================

		// Companion functions to above,

		// used to mark the supplied conditions as to-be-evaluated
		this.mustEvaluate = function(conditionArray){
			var _stateFlowObj = this;
			if(conditionArray){
				var arrLength = conditionArray.length;

				for (var i=0; i< arrLength; i++){
					var item= _stateFlowObj._conditions[conditionArray[i]];
					if(item)
						item.evaluated = false;
					else
						console.log('SF - mustEvaluate() - item [ %s ] is not valid. cannot enforce a re-check', conditionArray[i]);
				}
			}
		};

		// used to evaluate True conditions in an array
		// subsequent conditions in array are evaluated lazily & chained sequentially only if the current condition is true.
		// otherwise, Exits chain with false [indicating condition set is invalid]
		// Warning - empty array will return true. [ie. condition set is valid, useful to allow flow actions even when no conditions are provided]
		/* Returns
			Resolve with 	True -  if all conditions evaluated to true,
		 				False - on the first occurence of a false condition (does not evaluate the next one)


			rejects with error - if any error during the sequence
		*/

		function eval_IsCLabelArray (originFlow,stateFlowObj,array,index,length,ctx,prevOp){
			if (index<length){
				var item = stateFlowObj._conditions[array[index]];

				if (item){
					// console.log('SF - eval_IsCLabelArray() - index #%s , condition = %s, length %s, stateFlowObj = %s, array = %s', index, item.name, length,stateFlowObj,array);

					if (item.evaluated ){
						// console.log('condition [%s] : item.evaluated exists as ',item.name, item, ctx);

						if (item.value == true){
							// console.log('condition [%s] : since condition is valued  true, Checking for next condition ',item.name, item, ctx);

							return eval_IsCLabelArray(originFlow,stateFlowObj,array,index+1,length,ctx,prevOp);
						}else {
							// console.log('condition [%s] : since cond is valued false, resolving as [False] ',item.name, item, ctx);

							return $q.resolve(false);
						}
					}else {
						// console.log('calling condition [%s] testFn with ctx as ',item.name, ctx);
						return item.testFn(originFlow,stateFlowObj,ctx,prevOp)
								.then(function s(valid){
									// console.log('condition [%s] testFn evaluated as ',item.name,valid);

									if (valid == true){
										return eval_IsCLabelArray(originFlow,stateFlowObj, array,index+1,length,ctx,prevOp);
									}else{
										return $q.resolve(false);
									}
								}, function f(err){
									return $q.reject(err);
								})
								.catch(function(err){
									return $q.reject(err);
								});
					}
				}else {
					return $q.reject(' IS condition [ '+ array[index] +' ] is not defined. cannot check');
				}
			}else {
				// console.log('SF - eval_IsCLabelArray() - index #%s is >= length %s, resolving true...  stateFlowObj = %s, array = %s', index, length,stateFlowObj,array);

				return $q.resolve(true);
			}
		};


		// used to evaluate False conditions in an array. (exact inverse of above function)
		// subsequent conditions in array are evaluated lazily & chained sequentially only if the current condition is false.
		// otherwise, Exits chain with false [indicating condition set is invalid]
		// Warning - empty array will return true. [ie. condition set is valid, useful to allow flow actions even when no conditions are provided]
		/* Returns
			Resolve with 	True -  if all conditions evaluated to false,
		 				False - on the first occurence of a true condition (does not evaluate the next one)


			rejects with error - if any error during the sequence
		*/

		function eval_NotCLabelArray (originFlow,stateFlowObj, array, index, length, ctx, prevOp ){
			if (index<length){
				var item = stateFlowObj._conditions[array[index]];

				if (item){
					// console.log('SF - eval_NotCLabelArray() - index #%s , condition = %s, length %s, stateFlowObj = %s, array = %s', index, item.name, length,stateFlowObj,array);

					if (item.evaluated ){
						if (item.value == false){
							return eval_NotCLabelArray(originFlow,stateFlowObj,array,index+1,length,ctx,prevOp);
						}else {
							return $q.resolve(false);
						}
					}else {
						// console.log('calling item [%s] testFn with ctx as ',item.name, ctx);
						return item.testFn(originFlow,stateFlowObj,ctx,prevOp)
								.then(function s(valid){
									if (valid == false){
										return eval_NotCLabelArray(originFlow,stateFlowObj, array,index+1,length,ctx,prevOp);
									}else{
										return $q.resolve(false);
									}
								}, function f(err){
									return $q.reject(err);
								})
								.catch(function(err){
									return $q.reject(err);
								});
					}
				}

				else {
					return $q.reject('NOT condition [ '+ array[index] +' ] is not defined. cannot check');
				}

			}else {
				// console.log('SF - eval_NotCLabelArray() - index #%s is >= length %s, resolving true...  stateFlowObj = %s, array = %s', index, length,stateFlowObj,array);

				return $q.resolve(true);
			}
		};
	//==============================================================================================

		// Forcibly Sets (one or more) conditions' value as true & marks them as evaluated
		this.setTrue = function (conditionArray){
			var _stateFlowObj = this;
			var arrLength = conditionArray.length;

			for (var i=0; i< arrLength; i++){
				_stateFlowObj._conditions[conditionArray[i]].value = true;
				_stateFlowObj._conditions[conditionArray[i]].evaluated = true;
			}
		};

	//==============================================================================================

		// Forcibly Sets (one or more) conditions' value as false & marks them as evaluated
		this.setFalse = function(conditionArray){
			var _stateFlowObj = this;
			var arrLength = conditionArray.length;

			for (var i=0; i< arrLength; i++){
				_stateFlowObj._conditions[conditionArray[i]].value = false;
				_stateFlowObj._conditions[conditionArray[i]].evaluated = true;
			}
		};


	//==============================================================================================
		this.extends = function(stateFlowObj){
			this._conditions= stateFlowObj._conditions || {};
			this._flows= stateFlowObj._flows || {};
		}


		//==============================================================================================

		/* Attach a debugger callback to this StateFlowObj & its dependencies
			the callback (if attached) will be invoked after a state cycle completes from a defined entry point, with the state data as param
			& must accept a (err, params)
				params -  will contain all parameters passed to the callback.
				err - will contain error type & response on error, otherwise Null.
		*/

		this.attachDebugCallback = function (debugCallback){
			if (debugCallback){
				_self = this;

				_self.debugCallback = debugCallback;

				for (var sf in _self._dependencies){
					sf.debugCallback = debugCallback;
				}
			}
		};


		this.getConfig_FlowTypes = function(){
			return SF_FLOWTYPES;
		};

		/*==============================================================================================
			!!!!!!!!!!!!!!!~ END OF STATEFLOW CLASS DEFN ~!!!!!!!!!!!!!!!!!!!!!!!!!
		/*============================================================================================== */

	};


	/*==============================================================================================
		!!!!!!!!!!!!!!!~ END OF SERVICE DEFN ~!!!!!!!!!!!!!!!!!!!!!!!!!
	/*============================================================================================== */

	return {
		StateFlow:StateFlow
	};

};




/*	LICENSE FOR THE USE OF CODE THAT FOLLOWS BELOW

Copyright © 2011-2015 Paul Vorbach <paul@vorba.ch>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the “Software”), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

window.sf_clone = (function () {
	'use strict';

	var nativeMap;
	try {
		nativeMap = Map;
	} catch (_) {
		// maybe a reference error because no `Map`. Give it a dummy value that no
		// value will ever be an instanceof.
		nativeMap = function () {};
	}

	var nativeSet;
	try {
		nativeSet = Set;
	} catch (_) {
		nativeSet = function () {};
	}

	var nativePromise;
	try {
		nativePromise = Promise;
	} catch (_) {
		nativePromise = function () {};
	}

	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	 */
	function clone(parent, circular, depth, prototype) {
		var filter;
		if (typeof circular === 'object') {
			depth = circular.depth;
			prototype = circular.prototype;
			filter = circular.filter;
			circular = circular.circular;
		}
		// maintain two arrays for circular references, where corresponding parents
		// and children have the same index
		var allParents = [];
		var allChildren = [];

		var useBuffer = typeof Buffer != 'undefined';

		if (typeof circular == 'undefined')
			circular = true;

		if (typeof depth == 'undefined')
			depth = Infinity;

		// recurse this function so we don't reset allParents and allChildren
		function _clone(parent, depth) {
			// cloning null always returns null
			if (parent === null)
				return null;

			if (depth === 0)
				return parent;

			var child;
			var proto;
			if (typeof parent != 'object') {
				return parent;
			}

			if (parent instanceof nativeMap) {
				child = new nativeMap();
			} else if (parent instanceof nativeSet) {
				child = new nativeSet();
			} else if (parent instanceof nativePromise) {
				child = new nativePromise(function (resolve, reject) {
					parent.then(function (value) {
						resolve(_clone(value, depth - 1));
					}, function (err) {
						reject(_clone(err, depth - 1));
					});
				});
			} else if (clone.__isArray(parent)) {
				child = [];
			} else if (clone.__isRegExp(parent)) {
				child = new RegExp(parent.source, __getRegExpFlags(parent));
				if (parent.lastIndex) child.lastIndex = parent.lastIndex;
			} else if (clone.__isDate(parent)) {
				child = new Date(parent.getTime());
			} else if (useBuffer && Buffer.isBuffer(parent)) {
				child = new Buffer(parent.length);
				parent.copy(child);
				return child;
			} else {
				if (typeof prototype == 'undefined') {
					proto = Object.getPrototypeOf(parent);
					child = Object.create(proto);
				} else {
					child = Object.create(prototype);
					proto = prototype;
				}
			}

			if (circular) {
				var index = allParents.indexOf(parent);

				if (index != -1) {
					return allChildren[index];
				}
				allParents.push(parent);
				allChildren.push(child);
			}

			if (parent instanceof nativeMap) {
				var keyIterator = parent.keys();
				while (true) {
					var next = keyIterator.next();
					if (next.done) {
						break;
					}
					var keyChild = _clone(next.value, depth - 1);
					var valueChild = _clone(parent.get(next.value), depth - 1);
					child.set(keyChild, valueChild);
				}
			}
			if (parent instanceof nativeSet) {
				var iterator = parent.keys();
				while (true) {
					var next = iterator.next();
					if (next.done) {
						break;
					}
					var entryChild = _clone(next.value, depth - 1);
					child.add(entryChild);
				}
			}

			for (var i in parent) {
				var attrs;
				if (proto) {
					attrs = Object.getOwnPropertyDescriptor(proto, i);
				}

				if (attrs && attrs.set == null) {
					continue;
				}
				child[i] = _clone(parent[i], depth - 1);
			}

			if (Object.getOwnPropertySymbols) {
				var symbols = Object.getOwnPropertySymbols(parent);
				for (var i = 0; i < symbols.length; i++) {
					// Don't need to worry about cloning a symbol because it is a primitive,
					// like a number or string.
					var symbol = symbols[i];
					child[symbol] = _clone(parent[symbol], depth - 1);
				}
			}

			return child;
		}

		return _clone(parent, depth);
	}

	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function clonePrototype(parent) {
		if (parent === null)
			return null;

		var c = function () {};
		c.prototype = parent;
		return new c();
	};

	// private utility functions

	function __objToStr(o) {
		return Object.prototype.toString.call(o);
	}
	clone.__objToStr = __objToStr;

	function __isDate(o) {
		return typeof o === 'object' && __objToStr(o) === '[object Date]';
	}
	clone.__isDate = __isDate;

	function __isArray(o) {
		return typeof o === 'object' && __objToStr(o) === '[object Array]';
	}
	clone.__isArray = __isArray;

	function __isRegExp(o) {
		return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	}
	clone.__isRegExp = __isRegExp;

	function __getRegExpFlags(re) {
		var flags = '';
		if (re.global) flags += 'g';
		if (re.ignoreCase) flags += 'i';
		if (re.multiline) flags += 'm';
		return flags;
	}
	clone.__getRegExpFlags = __getRegExpFlags;

	return clone;
})();
